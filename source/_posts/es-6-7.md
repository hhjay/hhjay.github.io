---
title: ECMA Script 6/7新特性
date: 2018-04-23 10:08:32
tags: js
---

## es6
- 块作用域
    - 块作用域和函数作用域：var声明变量时会声明提前，即在函数头部就声明变量，但let是在代码块里声明
    ```JavaScript
        // 函数作用域
        function A() {
            // 变量在此处已声明
            console.log(i); // undefind
            if( true ) {
                i = 1;
                console.log(i); // 1
            }
            var i = 0;
            console.log(i); // 0
        }
        console.log(i); // i未声明
        /****** 这是一条优雅的分割线 ********/
        // 块作用域
        function B() {
            let i = 0;
            if( true ) {
                console.log(1, i); // error
                let i = 1;
                console.log(2, i); // 1 是if里面代码块的i
            }
            console.log(3, i); // 0 是function里面代码块的i
        }
    ```
    - let：声明变量，在let所在代码块里有效
    - const：声明常量，一旦声明不能修改
    - let和const的区别
        - let可以修改，const不能修改
        - const指向变量所在的地址，所以如果将变量指向的是一个对象，那么常量存的只是地址，故对象是可以修改的。
        ```JavaScript
            const a = {b: 111};
            console.log(a); // { b: 111 }
            a.b = 222;
            console.log(a) // { b: 222 }
        ```
- 模板字符串
```JavaScript
    // 可换行
    var a = `This 
     is 
     test`
    //  可插入变量
    var name = "hhj", b = `My name is ${ name }`;
    // 大括号内可运算
    var obj = { x: 2, y: 4 }; c = `this is run ${ obj.x * obj.y }`;
    // 函数调用
    function fn() { return "function" }
    var c = `this is ${ fn() }`;
```
- 对象拓展
    - 直接写入变量和函数、允许字面变量用表达式作为对象的属性名
    ```JavaScript
        // 直接写入变量和函数
        var name = "hhj", a = {
            sex: "man",
            name,
            getName
        }
        function getName() {
            console.log(this.name);
        }
        a.getName(); // hhj
    ```
    - Symbol
        - 是一种新的原始数据类型，通过Symbol函数生成，表示独一无二的ID
    - Proxy
        - 用于修改某些操作的默认行为，在目标对象之前，做一层拦截,外界对该对象的修改和访问都要经过它，故可以用它来监听对象的修改之类的(和defineProtype对比)。。
        ```JavaScript
            var a = {
                name: "hhj"
            }
            // 只是举例，可以有set...
            var px = new Proxy(a, {
                get: function(tar, proto) {
                    return proto in tar ? tar[proto] : "man";
                }
            })
            px.name; // hhj
            px.sex;  // man
        ```
- 函数拓展
    - 默认参数

- rest运算符...
    - 展开数组，替代apply
    - 合并数组
    - 可将字符串变为数组
    ```JavaScript
        // 展开数组
        var arr = [2, 5, 3];
        Math.max.apply(null, arr);
        Math.max(...arr);
        // 合并数组
        var a1 = [1, 2], a2 = [3, 6];console.log([...a1, a2]); // [1, 2, 3, 6]
        // 字符串转为数组
        var a = [..."hhj"]; // ["h", "h", "j"]
    ```
- 箭头函数
    - 函数内的this是绑定定义时的对象，而非使用时的对象
    - 没有arguments对象、不能当成构造函数（即不能new）
    ```JavaScript
        var fn = ()=>"hhj"; // 上下一样
        var fn = function() { return "hhj" };
    ```
- Set和Map
- 遍历器
- Promise
- Class
- 模块和导入

## es7
- includes
    - 数组的includes
    - 与indexOf的区别
        - arr.includes(x) > == arr.indexOf(x) >= 0
        - includes可以找到NaN
        ```JavaScript
            [NaN].includes(NaN) // true
        ```
- 指数运算符
    - x ** y
    ```JavaScript
        2 ** 3 // 8
    ```
- Object
    - values
    - getOwnPropertyDescriptors：获取对象的自身属性描述
    ```JavaScript
        var obj = { book: "1111" };
        Object.getOwnPropertyDescriptors(obj);
        /**
            {
                book: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: "1111",
                    __proto__: {
                        constructor: f()/Object,
                        hasOwnProperty: f(),
                        isPrototypeOf: f(),
                        propertyIsEnumerable: f(),
                        toLocaleString: f(),
                        toString: f(),
                        valueOf: f()
                    }
                }
            }
        */
    ```

- 字符填充符
```
    'js'.padStart(10);   // "        js"
    'js'.padEnd(10);     // "js        "
    'js'.padStart(10, '**'); // "********js"
```
- 异步函数
    - async/await
    ```JavaScript
        async function fetchG() {
            try {
                let req1 = await fetch();
                let req2 = await req1.next();
                return req2;
            }
        }
    ```

## es8

## 怎么兼容

## 参考链接
- [IMWeb.es6](http://imweb.io/topic/55e330d6771670e207a16bbb)
- [w3ctech.es7](https://w3ctech.com/topic/1614)